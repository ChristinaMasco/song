#' @title Test the accuracy of a song overlap null model.
#' 
#' @description
#' Given a list of non-interacting pairs of individuals, 
#' \code{song.AccuracyTest} calculates the difference between the actual amount
#' of chance overlap and the amount predicted by the model. This function can 
#' be used to determine which of the randomization methods included in the 
#' package (\code{\link{song.RandomizeSampleGaps}}, 
#' \code{\link{song.RandomizeKeepGaps}}, or 
#' \code{\link{song.RandomizeKeepSongOrder}}) is best for a given system. 
#'
#' @details
#' Non-interacting pairs (i.e. individuals that are separated by time or 
#' space) should overlap some amount by chance. The accuracy of a song overlap
#' null model can be measured as the difference between this amount and the
#' prediction generated by the model. 
#' 
#' When assembling a data set for this analysis, individuals should be 
#' randomly assigned to pairs, and the start time of each individual's 
#' performance should be randomly selected. These procedures ensure that any 
#' overlap occuring during these "non-interactions" is due to chance alone.
#' It is important to note that the quality of the accuracy measurement depends
#' on the number of non-interacting pairs included in the analysis.
#'  
#' @param rndm.pairs A list created by \code{\link{song.BatchReadSongs}} that
#' contains the performance statistics of non-interacting pairs.
#' @param num.rand A numeric value indicating the desired number of 
#' randomizations.
#' @param overlap.function The function to be used to calculate the amount of
#' overlap. \code{\link{song.TimeOverlap}} returns the duration of overlap
#' in seconds; \code{\link{song.NumOverlap}} returns the number of overlapping 
#' songs.
#' @param randomize.function The function to be used to generate the randomized
#' performances for each individual. Options include 
#' \code{\link{song.RandomizeSampleGaps}}, 
#' \code{\link{song.RandomizeKeepGaps}}, and 
#' \code{\link{song.RandomizeKeepSongOrder}}.
#'
#' @return \code{song.AccuracyTest} returns a list containing the results of the  
#' simulations (see \code{\link{song.Simulate}} for a description of the 
#' output) and a named vector containing the following components:
#' \describe{
#'   \item{Average Error}{The average difference between the actual and 
#'   predicted amounts of overlap.}
#'   \item{Average Percent Error}{The average error expressed as a percent of 
#'   the total interaction. If overlap was measured as a duration, this value
#'   represents the average error divided by the total duration of the 
#'   interaction. If overlap was measured as the number of overlapping songs, 
#'   this value represents the average error divided by the total number of 
#'   songs in the interaction.}
#'   \item{P < 0.025}{The number of pairs for which overlapping occurred 
#'   significantly more often than predicted (at alpha level 0.05). In these
#'   cases, the model underestimated the amount of overlap due to chance.}
#'   \item{P > 0.975}{The number of pairs for which overlapping occurred
#'   significantly less often than predicted (at alpha level 0.05). In these
#'   cases, the model overestimated the amount of overlap due to chance.}
#' }
#' 
#' @seealso
#' \code{\link{song.HowManyRand}} to evaluate the accuracy of a model as a
#' function of the number of randomizations.

song.AccuracyTest <- function(rndm.pairs, num.rand, overlap.function, 
                              randomize.function){
  ## calculate the observed and expected amounts of overlap
  sim <- song.BatchSimulate(rndm.pairs, num.rand, overlap.function,
                             randomize.function)
  ## extract values from the results list
  ## setting the first individual to sing as the reference individual
  obs.1 <- unlist(lapply(sim, function(x) x$observed[2,1]))
  exp.1 <- unlist(lapply(sim, function(x) x$expected[2,1]))
  p.1 <- unlist(lapply(sim, function(x) x$p.values[2,1]))
  ## setting the second individual to sing as the reference individual
  obs.2 <- unlist(lapply(sim, function(x) x$observed[1,2]))
  exp.2 <- unlist(lapply(sim, function(x) x$expected[1,2]))
  p.2 <- unlist(lapply(sim, function(x) x$p.values[1,2]))
  
  
  ## count totals for % of total calculation  
  if(identical(overlap.function,song.TimeOverlap)){
    ## if TimeOverlap, total = total duration of interaction
    total <- unlist(lapply(rndm.pairs, function(x) x[[1]]$end.record.time -
                             x[[1]]$start.record.time))
  } else{
    ## if NumOverlap, total = total number of songs 
    total <- unlist(lapply(rndm.pairs, function(x) x[[1]]$songs.num + 
                             x[[2]]$songs.num))
  }
  ## error calculations
  dx.1 <- abs(obs.1 - exp.1)
  dx.2 <- abs(obs.2 - exp.2)
  dx <- rowMeans(cbind(dx.1, dx.2))
  avg.dx <- mean(dx)
  avg.pct <- mean(dx/total)
  
  num.overlap.1 <- sum(p.1 < 0.025)
  num.avoid.1 <- sum(p.1 > 0.975)
  num.overlap.2 <- sum(p.2 < 0.025)
  num.avoid.2 <- sum(p.2 > 0.975)
  
  num.overlap <- sum(num.overlap.1, num.overlap.2)
  num.avoid <- sum(num.avoid.1, num.avoid.2)
  
  ## build output
  metrics <- c(avg.dx, avg.pct, num.overlap, num.avoid)
  names(metrics) <- c("Average Error", "Average Percent Error", "P < 0.025", 
                     "P > 0.975")
  output <- list("error.metrics"= metrics, "simulations" = sim)
  return(output)
}

#' @title Determine the optimal number of randomizations.
#' 
#' @description
#' \code{song.HowManyRand} evaluates the accuracy of a null model as a function of
#' the number of randomizations, allowing the user to examine the tradeoff between 
#' accuracy and run time.   
#'
#' @param rndm.pairs A list created by \code{\link{song.BatchReadSongs}} that
#' contains the performance statistics of non-interacting pairs. 
#' @param n A numeric vector indicating the desired number of 
#' randomizations. Unless specified otherwise, the function will evaluate the
#' accuracy at 10, 100, and 1000 randomizations.
#' @param overlap.function The function to be used to calculate the amount of
#' overlap. \code{\link{song.TimeOverlap}} returns the duration of overlap
#' in seconds; \code{\link{song.NumOverlap}} returns the number of overlapping 
#' songs.
#' @param randomize.function The function to be used to generate the randomized
#' performances for each individual. Options include 
#' \code{\link{song.RandomizeSampleGaps}}, 
#' \code{\link{song.RandomizeKeepGaps}}, and 
#' \code{\link{song.RandomizeKeepSongOrder}}. 
#'
#' @return \code{song.HowManyRand} returns a list containing the results of 
#' the simulations (see \code{\link{song.Simulate}} for a description of the 
#' output) and a data frame containing the number of randomizations, the 
#' average error, the average percent error, and the run time.
#' 
#' @seealso 
#' \code{\link{song.AccuracyTest}} for testing the accuracy of the null models.

song.HowManyRand <- function(rndm.pairs, n = c(10, 100, 1000), 
                              overlap.function, randomize.function){
  accuracy <- list()
  runtime <- numeric()
  for (i in 1:length(n)){
    ## start the clock
    ptm <- proc.time()
    ## run the simulation and test accuracy
    accuracy[[i]] <- song.AccuracyTest(rndm.pairs, n[i], overlap.function,
                                       randomize.function)
    ## stop the clock and store elapsed time
    run <- as.vector(proc.time() - ptm)
    runtime[i] <- run[3]    
  }
  ## build output
  results <- lapply(accuracy, function(x) x$error.metrics)
  tmp <- do.call(rbind, results)
  metrics <- data.frame(n, tmp[,1], tmp[,2], tmp[,3], tmp[,4], runtime)
  names(metrics) <- c("N","Average Error", "Average Percent Error", "P < 0.025", 
                      "P > 0.975", "Run Time")
  
  simulations <- lapply(accuracy, function(x) x$simulations)
  output <- list("error.metrics" = metrics, "simulations" = simulations)
  return(output)
}
#' @title Plot the relative timing of songs during an interaction.
#'
#' @description
#' \code{song.PlotSongs} creates a \code{\link{ggplot}} object depicting the
#' relative timing of songs during an interaction. Each song is represented by
#' a line segment plotted along a time axis. Songs are color-coded and
#' plotted by individual.
#'
#' @details
#' The optional parameters \code{start.time} and \code{end.time} set the limits
#' of the x-axis of the plot. If specified, these parameters can be used to
#' view select portions of an interaction. This practice often results in
#' the following warning message: "Removed ## rows containing missing values
#' (geom_segment)." This warning can be safely ignored.
#'
#' @param indivs A list created by \code{\link{song.BuildAllIndivs}} or
#' \code{\link{song.ReadSongList}} that contains the performance statistics of
#' each individual.
#' @param start.time A numeric value indicating the start time of the
#' interaction in seconds. An optional parameter - if not specified, the
#' minimum start time is used (i.e. the start of the first song).
#' @param end.time A numeric value indicating the end time of the
#' interaction in seconds. An optional parameter - if not specified, the
#' maximum end time is used (i.e. the end of the last song).
#'
#' @examples
#' c <- song.BuildAllIndivs(chickadees)
#'
#' ## Plot the entire interaction
#' song.PlotSongs(c)
#'
#' ## Plot the songs occuring between 02m 30s and 02m 50s
#' song.PlotSongs(c, 150, 170)
#' @export

song.PlotSongs <- function(indivs, start.time = NA, end.time = NA){
  all.songs <- matrix(0, 0, 2)
  all.names <- character(0)
  ## extract start and end times from individual performance stats
  for (i in 1:length(indivs)){
    all.songs <- rbind(all.songs, indivs[[i]]$songs)
    all.names <- c(all.names, rep(indivs[[i]]$ID, indivs[[i]]$songs.num))
  }
  my.df <- data.frame(Individuals = all.names, Start = all.songs[,1],
                      End = all.songs[,2])
  ## check if user specified a time range
  if (is.na(start.time)){
    start.time <- min(my.df$Start)
  }
  if (is.na(end.time)){
    end.time <- max(my.df$End)
  }
  ## build ggplot object
  require(ggplot2)
  songs.plot <- ggplot(data = my.df, aes(x = Individuals, ymin = Start,
                                         ymax = End, colour = Individuals)) +
    geom_linerange(size = I(2)) +
    scale_y_continuous("Time", limits=c(start.time, end.time)) +
    coord_flip() + theme_bw() + theme(legend.position = "none")
  return(songs.plot)
}

#' @title Plot the observed and expected amounts of song overlap.
#'
#' @description
#' \code{song.PlotResultsDensity} creates a \code{\link{ggplot}} object that
#' depicts the observed amount of overlap relative to the expected amount for
#' each possible pair of individuals. This function can be used to visualize
#' the output generated by \code{\link{song.Simulate}}.
#'
#' @param results A list created by \code{\link{song.Simulate}} that contains
#' the observed and expected amounts of overlap for an interaction.
#'
#' @return
#' \code{song.PlotResultDensity} returns a \code{\link{ggplot}} object in which
#' each panel of the plot represents a pairwise interaction. Each row (and fill
#' color) specifies the reference individual. Each column (and line color)
#' specifies the target individual. Within each panel, the observed amount of
#' overlap (dashed line) is plotted relative to the null distribution (filled
#' curve). The p-value corresponding to each pairwise interaction appears in the
#' upper right corner of each panel.
#'
#' @examples
#' ## Black-capped chickadees
#' c <- song.BuildAllIndivs(chickadees)
#' c.rand <- song.Simulate(c, 100, song.TimeOverlap,
#'                         song.RandomizeSampleGaps)
#' song.PlotResultsDensity(c.rand)
#'
#' ## Rufous-and-white wrens
#' w <- song.BuildAllIndivs(wrens)
#' w.rand <- song.Simulate(w, 100, song.TimeOverlap,
#'                         song.RandomizeKeepSongOrder)
#' song.PlotResultsDensity(w.rand)
#'
#' ## Long-tailed manakins
#' m <- song.BuildAllIndivs(manakins)
#' m.rand <- song.Simulate(m, 100, song.TimeOverlap,
#'                         song.RandomizeSampleGaps)
#' song.PlotResultsDensity(m.rand)
#' @import ggplot2
#' @import reshape2
#' @export
song.PlotResultsDensity <- function(results){
  ## create results data frame
  observed.df <- melt(results$observed)
  expected.df <- melt(results$expected)
  p.values.df <- melt(results$p.values)
  all.df <- observed.df
  all.df <- cbind(all.df, expected.df[,3])
  all.df <- cbind(all.df, p.values.df[,3])
  names(all.df) <- c("Reference", "Target", "Observed", "Expected", "p.value")
  ## create null distribution data frame
  density.df <- melt(results$randomized,
                     names = c("Reference", "Target", "randnum"))[,-3]
  names(density.df) <- c("Reference", "Target", "Overlap")
  indivs.names <- colnames(results$observed)
  density.df$Reference <- as.factor(indivs.names[density.df$Reference])
  ## make the order of the rows the same as in the p.values table
  density.df$Reference <- factor(density.df$Reference, colnames(results$p.values))
  density.df$Target <- as.factor(indivs.names[density.df$Target])
  ## make the order of the cols the same as in the p.values table
  density.df$Target <- factor(density.df$Target,
                                  colnames(results$p.values))
  ## create p-value labels
  indiv.names <- colnames(results$observed)
  tmp.refs <- character(0)
  tmp.targets <- character(0)
  tmp.maxdensity <- numeric(0)
  tmp.pvalue <- character(0)
  tmp.xvalue <- numeric(0)

  for (T in indiv.names){
    for (R in indiv.names){
      x <- density.df$Overlap[density.df$Reference == R &
                                density.df$Target == T]
      maxdens <- max(density(x, kernel = "gaussian", adjust = 1)$y)
      tmp.refs <- c(tmp.refs, R)
      tmp.targets <- c(tmp.targets, T)
      tmp.maxdensity <- c(tmp.maxdensity, maxdens)
      mypv <- all.df$p.value[all.df$Reference == R & all.df$Target == T]
      if (mypv < 0.01){
        tmp.pvalue <- c(tmp.pvalue, "p < 0.01")
      } else{
        if (mypv > 0.99){
          tmp.pvalue <- c(tmp.pvalue, "p > 0.99")
        } else{
          tmp.pvalue <- c(tmp.pvalue,
                          paste("p =", round(mypv,2), sep =""))
        }
      }
      tmp.xvalue <- c(tmp.xvalue, max(results$observed, results$randomized))
    }
  }
  p.df <- data.frame(Reference = tmp.refs, Target = tmp.targets,
                     xpos = tmp.xvalue, ypos = tmp.maxdensity,
                     mylabel = tmp.pvalue)
  ## adjust vertical alignment
  for (R in indiv.names){
    p.df$ypos[p.df$Reference == R] <- max( p.df$ypos[p.df$Reference == R])
  }

  ## build ggplot object
  require(ggplot2)
  overlap.density.plot <- ggplot(data = density.df,
                                 aes(x = Overlap, fill = Reference,
                                     colour = Target)) +
    geom_density(alpha = 0.2) +  theme_bw() + scale_y_continuous("Density") +
    geom_vline(data = all.df,
               aes(xintercept = Observed),
               colour = I("black"), linetype = 2, alpha = 0.5, size = 0.75) +                                                    geom_text(data = p.df, aes(x = xpos, y = ypos, label = mylabel), hjust = 1, vjust = 1, size = 4, col = "black") +
    facet_grid(Reference ~ Target, scales = "free_y") +
    theme(legend.position = "none")
  return(overlap.density.plot)
}

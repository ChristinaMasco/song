#' @title Plot the relative timing of songs during an interaction.
#' 
#' @description
#' \code{song.PlotSongs} creates a \code{\link{ggplot}} object depicting the 
#' relative timing of songs during an interaction. Each song is represented by
#' a line segment plotted along a time axis. Songs are color-coded and 
#' plotted by individual.
#' 
#' @details
#' The optional parameters \code{start.time} and \code{end.time} set the limits
#' of the x-axis of the plot. If specified, these parameters can be used to 
#' view select portions of an interaction. This practice often results in 
#' the following warning message: "Removed ## rows containing missing values 
#' (geom_segment)." This warning can be safely ignored. 
#' 
#' @param indivs A list created by \code{\link{song.BuildAllIndivs}} or 
#' \code{\link{song.ReadSongList}} that contains the performance statistics of 
#' each individual.
#' @param start.time A numeric value indicating the start time of the 
#' interaction in seconds. An optional parameter - if not specified, the 
#' minimum start time is used (i.e. the start of the first song).
#' @param end.time A numeric value indicating the end time of the 
#' interaction in seconds. An optional parameter - if not specified, the 
#' maximum end time is used (i.e. the end of the last song).
#'
#' @examples
#' c <- song.BuildAllIndivs(chickadees)
#' 
#' ## Plot the entire interaction
#' song.PlotSongs(c)
#' 
#' ## Plot the songs occuring between 02m 30s and 02m 50s 
#' song.PlotSongs(c, 150, 170)

song.PlotSongs <- function(indivs, start.time = NA, end.time = NA){
  all.songs <- matrix(0, 0, 2)
  all.names <- character(0)
  ## extract start and end times from individual performance stats
  for (i in 1:length(indivs)){
    all.songs <- rbind(all.songs, indivs[[i]]$songs)
    all.names <- c(all.names, rep(indivs[[i]]$ID, indivs[[i]]$songs.num))
  }
  my.df <- data.frame(Individuals = all.names, Start = all.songs[,1],
                      End = all.songs[,2])
  ## check if user specified a time range
  if (is.na(start.time)){
    start.time <- min(my.df$Start)
  }
  if (is.na(end.time)){
    end.time <- max(my.df$End)
  }
  ## build ggplot object
  songs.plot <- ggplot(data = my.df, aes(x = Individuals, ymin = Start, 
                                         ymax = End, colour = Individuals)) +
    geom_linerange(size = I(2)) + 
    scale_y_continuous("Time", limits=c(start.time, end.time)) +
    coord_flip() + theme_bw() + theme(legend.position = "none")
  return(songs.plot)
}

#' @title Plot the observed and expected amounts of song overlap.
#' 
#' @description
#' \code{song.PlotResultsDensity} creates a \code{\link{ggplot}} object that
#' depicts the observed amount of overlap relative to the expected amount for 
#' each possible pair of individuals. This function can be used to visualize
#' the output generated by \code{\link{song.Simulate}}. 
#'
#' @param results A list created by \code{\link{song.Simulate}} that contains
#' the observed and expected amounts of overlap for an interaction.
#'
#' @return 
#' \code{song.PlotResultDensity} returns a \code{\link{ggplot}} object in which
#' each panel of the plot represents a pairwise interaction. Within each panel, 
#' the observed amount of overlap (dashed line) is plotted relative to the null
#' distribution (filled curve). The p-value corresponding to each pairwise 
#' interaction appears in the upper right corner of each panel.
#' 
#' @examples
#' ## Black-capped chickadees
#' c <- song.BuildAllIndivs(chickadees)
#' c.rand <- song.Simulate(c, 100, song.TimeOverlap, 
#'                         song.RandomizeSampleGaps)
#' song.PlotResultsDensity(c.rand)
#' 
#' ## Rufous-and-white wrens
#' w <- song.BuildAllIndivs(wrens)
#' w.rand <- song.Simulate(w, 100, song.TimeOverlap, 
#'                         song.RandomizeKeepSongOrder)
#' song.PlotResultsDensity(w.rand)
#' 
#' ## Long-tailed manakins
#' m <- song.BuildAllIndivs(manakins)
#' m.rand <- song.Simulate(m, 100, song.TimeOverlap, 
#'                         song.RandomizeSampleGaps)
#' song.PlotResultsDensity(m.rand)

song.PlotResultsDensity <- function(results){
  ## create results data frame
  observed.df <- melt(results$observed)
  expected.df <- melt(results$expected)
  p.values.df <- melt(results$p.values)
  all.df <- observed.df
  all.df <- cbind(all.df, expected.df[,3])
  all.df <- cbind(all.df, p.values.df[,3])
  names(all.df) <- c("Target", "Randomized", "Observed", "Expected", "p.value")
  ## create null distribution data frame
  density.df <- melt(results$randomized,
                     names = c("Target", "Randomized", "randnum"))[,-3]
  names(density.df) <- c("Target", "Randomized", "Overlap")
  indivs.names <- colnames(results$observed)
  density.df$Target <- as.factor(indivs.names[density.df$Target])
  ## make the order of the rows the same as in the p.values table
  density.df$Target <- factor(density.df$Target, colnames(results$p.values))
  density.df$Randomized <- as.factor(indivs.names[density.df$Randomized])
  ## make the order of the cols the same as in the p.values table
  density.df$Randomized <- factor(density.df$Randomized, 
                                  colnames(results$p.values))
  ## create p-value labels
  indiv.names <- colnames(results$observed)
  tmp.targets <- character(0)
  tmp.randomized <- character(0)
  tmp.maxdensity <- numeric(0)
  tmp.pvalue <- character(0)
  tmp.xvalue <- numeric(0)

  for (T in indiv.names){
    for (R in indiv.names){
      x <- density.df$Overlap[density.df$Target == T & 
                                density.df$Randomized == R]
      maxdens <- max(density(x, kernel = "gaussian", adjust = 1)$y)
      tmp.targets <- c(tmp.targets, T)
      tmp.randomized <- c(tmp.randomized, R)
      tmp.maxdensity <- c(tmp.maxdensity, maxdens)
      mypv <- all.df$p.value[all.df$Target == T & all.df$Randomized == R]
      if (mypv < 0.01){
        tmp.pvalue <- c(tmp.pvalue,
                        "p<0.01")
      } else{
        tmp.pvalue <- c(tmp.pvalue,
                        paste("p=", round(mypv,2), sep =""))
      }
      tmp.xvalue <- c(tmp.xvalue, max(results$observed))
    }
  }
  p.df <- data.frame(Target = tmp.targets, Randomized = tmp.randomized, 
                     xpos = tmp.xvalue, ypos = tmp.maxdensity, 
                     mylabel = tmp.pvalue)
  ## adjust vertical alignment
  for (T in indiv.names){
    p.df$ypos[p.df$Target == T] <- max( p.df$ypos[p.df$Target == T])
  }

  ## build ggplot object
  overlap.density.plot <- ggplot(data = density.df,
                                 aes(x = Overlap, fill = Target, 
                                     colour = Randomized)) +
    geom_density(alpha = 0.2) +  theme_bw() + scale_y_continuous("Density") +
    geom_vline(data = all.df,
               aes(xintercept = Observed),
               colour = I("black"), linetype = 2, alpha = 0.5, size = 0.75) +                                                    geom_text(data = p.df, aes(x = xpos, y = ypos, label = mylabel), hjust = 1, vjust = 1, size = 4, col = "black") +
    facet_grid(Target ~ Randomized, scales = "free_y") +
    theme(legend.position = "none")
  return(overlap.density.plot)
}
